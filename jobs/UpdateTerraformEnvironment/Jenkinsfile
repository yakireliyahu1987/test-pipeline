// Time to wait for a manual approval before running `terraform apply` (in minutes).
approval_timeout = 30
// Relative path to the Terraform environment directory. This directory should contain the
// "root" module for every environment which this pipeline manages.
environment_dir = "./environments"
// Path to the Terraform executable.
tf_command = "/usr/local/bin/terraform"
// Send email notifications.
email = false

properties([
    parameters([
        string(
            name: 'EnvironmentName'
        )
    ])
])

def exitCode

node {
    checkout scm

    environment = params.EnvironmentName
    if (!environment?.trim()) {
        error "Environment name cannot be empty."
    }
    if (!fileExists("${environment_dir}/${environment}")) {
        error "Cannot find environment '${environment}'."
    }

    echo "Running Terraform for environment ${environment}"

    // Set build name so that we can easily figure out which for which environment it ran.
    currentBuild.displayName = "#${BUILD_NUMBER}-${environment}"

    // Suppress user-oriented output. More info at:
    // https://www.terraform.io/guides/running-terraform-in-automation.html#controlling-terraform-output-in-automation
    withEnv(['TF_IN_AUTOMATION=true']) {
        stage('Init') {
            dir("${environment_dir}/${environment}") {
                ansiColor('xterm') {
                    sh "${tf_command} init -input=false"
                }
            }
        }
        stage('Plan') {
            dir("${environment_dir}/${environment}") {
                ansiColor('xterm') {
                    exitCode = sh script: "${tf_command} plan -detailed-exitcode -input=false -out=tfplan", returnStatus: true
                }

                // Stash plan output so that it can be reused by other nodes. In some cases,
                // Jenkins might schedule a part of a build to a different node. In these
                // cases, stashing allows the new node to use files which were generated by the
                // previous node.
                stash includes: 'tfplan', name: 'tfplans'

                if (email) {
                    // Notify committer about the pending apply.
                    ansiColor('xterm') {
                        plan = sh(script: "${tf_command} show -no-color tfplan", returnStdout: true).trim()
                    }

                    subject = "Terraform environment '${environment}' - manual approval pending"
                    // TODO Include timeout information in body.
                    body = "An apply operation on environment '${environment}' is pending manual " +
                        "approval. Terraform plan:\n\n${plan}" +
                        "\n\n${BUILD_URL}console"
                    emailext(
                        subject: subject,
                        body: body,
                        recipientProviders: [
                            [$class: 'CulpritsRecipientProvider'],
                        ],
                    )
                }
            }
        }
    }
}
// Run this stage only when the plan stage succeeded and there is a diff.
if (exitCode == 2) {
    stage('Apply') {
        timeout(time: approval_timeout, unit: 'MINUTES') {
            input 'Apply?'
        }
        node {
            withEnv(['TF_IN_AUTOMATION=true']) {
                dir("${environment_dir}/${environment}") {
                    // Unstash plan output.
                    unstash name: 'tfplans'
                    ansiColor('xterm') {
                        sh "${tf_command} apply -input=false tfplan"
                    }
                    // TODO Notify on failure (with output).
                }
            }
        }
    }
}
